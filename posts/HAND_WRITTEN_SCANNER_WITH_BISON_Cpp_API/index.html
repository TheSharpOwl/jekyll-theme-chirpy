<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Using Bison C++ API With Hand-written Scanner | The Sharp Owl</title><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Using Bison C++ API With Hand-written Scanner" /><meta name="author" content="Mohamad Ziad Alkabakibi" /><meta property="og:locale" content="en_US" /><meta name="description" content="In this post, I’ll talk about how can you use Bison’s C++ API. Take a look at the tutorial I wrote about using C API especially the parts about installing Bison latest version and Compiler Construction. Also, to gain more knowledge about how Bison works. Well, as I said in the C API post, you can’t use dynamic types such as std::string or std::vector as Bison types which is one of the reasons of using C++ API (The main reason is that C++ is cooler of course !)." /><meta property="og:description" content="In this post, I’ll talk about how can you use Bison’s C++ API. Take a look at the tutorial I wrote about using C API especially the parts about installing Bison latest version and Compiler Construction. Also, to gain more knowledge about how Bison works. Well, as I said in the C API post, you can’t use dynamic types such as std::string or std::vector as Bison types which is one of the reasons of using C++ API (The main reason is that C++ is cooler of course !)." /><link rel="canonical" href="https://thesharpowl.github.io/posts/HAND_WRITTEN_SCANNER_WITH_BISON_Cpp_API/" /><meta property="og:url" content="https://thesharpowl.github.io/posts/HAND_WRITTEN_SCANNER_WITH_BISON_Cpp_API/" /><meta property="og:site_name" content="The Sharp Owl" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-10-24T22:00:00+03:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Using Bison C++ API With Hand-written Scanner" /><meta name="twitter:site" content="@Ziad_Kabakibi" /><meta name="twitter:creator" content="@Mohamad Ziad Alkabakibi" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"mainEntityOfPage":{"@type":"WebPage","@id":"https://thesharpowl.github.io/posts/HAND_WRITTEN_SCANNER_WITH_BISON_Cpp_API/"},"description":"In this post, I’ll talk about how can you use Bison’s C++ API. Take a look at the tutorial I wrote about using C API especially the parts about installing Bison latest version and Compiler Construction. Also, to gain more knowledge about how Bison works. Well, as I said in the C API post, you can’t use dynamic types such as std::string or std::vector as Bison types which is one of the reasons of using C++ API (The main reason is that C++ is cooler of course !).","@type":"BlogPosting","url":"https://thesharpowl.github.io/posts/HAND_WRITTEN_SCANNER_WITH_BISON_Cpp_API/","headline":"Using Bison C++ API With Hand-written Scanner","dateModified":"2020-10-24T22:00:00+03:00","datePublished":"2020-10-24T22:00:00+03:00","author":{"@type":"Person","name":"Mohamad Ziad Alkabakibi"},"@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <script data-ad-client="ca-pub-2669958432404783" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --> <script src="/assets/js/post.min.js" async></script> <script src="/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/" alt="avatar"> <img src="/assets/img/sample/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">The Sharp Owl</a></div><div class="site-subtitle font-italic">Welcome to my blog</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightkMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightkMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/TheSharpOwl" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/Ziad_Kabakibi" target="_blank"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:window.open('mailto:' + ['example','doamin.com'].join('@'))" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" > <i class="fas fa-rss"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Using Bison C++ API With Hand-written Scanner</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Refactor the HTML structure. --> <!-- Suroundding the markdown table with '<div class="table-wrapper">. and '</div>' --> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Using Bison C++ API With Hand-written Scanner</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Oct 24, 2020, 10:00 PM +0300" > Oct 24, 2020 <i class="unloaded">2020-10-24T22:00:00+03:00</i> </span> by <span class="author"> Mohamad Ziad Alkabakibi </span></div><div> Updated <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, Dec 29, 2020, 7:24 PM +0300" > Dec 29, 2020 <i class="unloaded">2020-12-29T19:24:39+03:00</i> </span></div></div><div class="post-content"><p>In this post, I’ll talk about how can you use Bison’s C++ API. Take a look at the <a href="https://thesharpowl.github.io/posts/HAND_WRITTEN_SCANNER_WITH_BISON_C_API/">tutorial I wrote about using C API</a> especially the parts about installing Bison latest version and Compiler Construction. Also, to gain more knowledge about how Bison works.<br /> <br /></p><ol><li><p>Well, as I said in the C API post, you can’t use dynamic types such as <code class="language-plaintext highlighter-rouge">std::string</code> or <code class="language-plaintext highlighter-rouge">std::vector</code> as Bison types which is one of the reasons of using C++ API (The main reason is that C++ is cooler of course !).</p><p>Again this tutorial is not focusing on Bison itself, just the C++ API part.</p></li><li>We have a simple input file in an imperative language :<br /><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre> var some_identifer is integer
</pre></table></code></div></div><p><br /></p></li><li>Now let’s write a simple Scanner in C++ (same idea as the C one) :<br /></li></ol><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
</pre><td class="rouge-code"><pre>#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include&lt;string&gt;

// I know that global variables are often bad. Forgive me I wanna just explain the idea ((
std::ifstream fin;

std::string get_next_token()
{
    std::string s;
    char c;

    while (true)
    {
        // could be done better but organized it like this to edit only assignments and returns when using Bison API
        if (!fin.eof())
            fin.get(c);// get one character
        else
            return "";

        if (c == ' ' || c == '\n' || fin.eof())
        {
            if (s.empty()) // we only have this character
            {
                if (fin.eof())
                    return "";
                //otherwise go and see what's next
                return get_next_token();
            }
            else
            {
                if (!fin.eof())
                {
                   // now we need to put the pointer exactly after the word (undo the last step)
                   // NOTE : don't use unget if you reach the end of the file because it will clear eof bit and bad stuff will happen !!!
                   fin.unget();
                }

                if (s == "var") // the last word is var
                    return s;
                if (s == "integer")
                    return s;
                if (s == "is")
                    return s;
                if (!s.empty())// it means it is some identifier name
                    return  "Identifier";
            }
        }
        else if ((c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || c == '_') // reading some name
        {
            s += c; // add the char to the string
        }
        else
        {
            // we don't know what's that
            return "ERROR";
        }
    }
}
int main()
{

    fin.open("input.txt");
    std::string temp = get_next_token();
    while (!temp.empty())
    {
        // printing a space since our example is only one line for now
        std::cout &lt;&lt; temp &lt;&lt; " ";
        temp = get_next_token();

    }
    return 0;
}
</pre></table></code></div></div><ol><li>Now the Bison part. (not going to go deep into grammar rules or the way you design them. I learned grammar in Theoretical Computer Science course) but I will talk about the programming aspects.<br /><ul><li><h4 id="save-the-bison-file-with-ypp-extenstion-to-make-it-work-properly-with-a-c-compiler"><strong>Save the Bison file with .ypp extenstion to make it work properly with a C++ compiler</strong></h4></li><li><p>Bison file consists of 4 parts :</p><p>I. Defines and requirements (statementsstart with <code class="language-plaintext highlighter-rouge">%</code> usually).</p><p>II. C/С++ code part(s) for includes and signatures (will be at the beginning of the generated .h file)</p><p>III. Grammar part</p><p>IV. Function defintions’ part</p><h3 id="note-that-in-bisons-c-api-a-class-parser-is-generated-unlike-in-the-c-api-were-we-have-only-functions"><strong>Note that in Bison’s C++ API, a class <code class="language-plaintext highlighter-rouge">Parser</code> is generated unlike in the C API were we have only functions.</strong><br /></h3></li></ul></li><li>Take a look at this Bison with C++ example (I will explain after that) :</li></ol><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre><td class="rouge-code"><pre>%require "3.2"
%language "C++"
%define api.value.type variant
%define api.token.constructor
%define parse.assert

%code requires
{
    #pragma once
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    
    // forward decleration (1)
    namespace yy
    {
        class parser;
    }
}

%code
{    
    namespace yy
    {
        parser::symbol_type yylex(); // override (2)
        // no need to override the error function because it is already waiting for our implementation (3)
    }
}

%token IDENT VAR INT IS
%type &lt;std::string&gt; IDENT

%%

Program:
|Program VariableDeclaration
;

VariableDeclaration: VAR IDENT IS INT { /* no actions for now (4) */ }
;

%%
namespace yy
{
    parser::symbol_type yylex()
    {
        return  yy::parser::make_YYEOF ();
    }
    void parser::error(const std::string&amp; msg) //(3+)
    {
        std::cout&lt;&lt; "syntax error!\n";
    }
}

int main()
{
    yy::parser p; // (5)
    // will be deleted later just make sure it prints it
    std::cout &lt;&lt; "hello\n" &lt;&lt; std::endl;
    return 0;
}
</pre></table></code></div></div><ol><li><p>First, we are using Bison macros (not sure of their official name) which have <code class="language-plaintext highlighter-rouge">%</code> at the beginning of them:</p><ul><li>Adding a condition about the least version which can be used with the used programming language.</li><li><strong>Note: As the documentation says, C++ Bison API is pure always so no need to add <code class="language-plaintext highlighter-rouge">%define api.pure full</code> as we did in the C API.</strong></li><li><code class="language-plaintext highlighter-rouge">%define api.value.type variant</code> : As we know in C++, we don’t use <code class="language-plaintext highlighter-rouge">unions</code> (you can but the standard doesn’t recommend it usually. You can check <a href="https://en.cppreference.com/w/cpp/utility/variant">this</a> and <a href="https://stackoverflow.com/questions/42082328/where-to-use-stdvariant-over-union">this question</a>). So now you can directly just write the type of each token without the need to define a union with field names as we did in the C API.</li><li><p><code class="language-plaintext highlighter-rouge">%define api.token.constructor</code>: this one will generate functions in our .hpp file for each token which has a type. For example <code class="language-plaintext highlighter-rouge">%type &lt;std::string&gt; IDENT</code> generates a constructor : <code class="language-plaintext highlighter-rouge">make_IDENT(std::string)</code> (also another one <code class="language-plaintext highlighter-rouge">make_IDENT(std::string&amp;)</code>). As a result, we can use it in our scanner later, it will put the string in the parameter in the value which corresponds to our <code class="language-plaintext highlighter-rouge">IDENT</code> token and all we have to do is <code class="language-plaintext highlighter-rouge">return make_IDENT(string_variable)</code> (in the C API we had to do <code class="language-plaintext highlighter-rouge">lval-&gt;s = some_char_array</code> where s is the name of the char array field in our union and then return the token).</p></li><li><p><code class="language-plaintext highlighter-rouge">%define parse.assert</code> seems to help us with useful error messages and warnings according to <a href="https://www.gnu.org/software/bison/manual/html_node/_0025define-Summary.html">this doc page</a> :</p><blockquote><p>Directive: <code class="language-plaintext highlighter-rouge">%define parse.assert</code></p><ul><li>Languages(s): C, C++ <br /></li><li>Purpose: Issue runtime assertions to catch invalid uses. In C, some important invariants in the implementation of the parser are checked when this option is enabled.<br /><br /></li><li>In C++, when variants are used (see section C++ Variants), symbols must be constructed and destroyed properly. This option checks these constraints using runtime type information (RTTI). Therefore the generated code cannot be compiled with RTTI disabled (via compiler options such as -fno-rtti).<br /></li><li>Accepted Values: Boolean <br /></li><li>Default Value: false</li></ul></blockquote></li></ul></li><li><p><code class="language-plaintext highlighter-rouge">%code requires</code> block which contains the required things which must be added at the beginning of our .hpp file. For example, we need <code class="language-plaintext highlighter-rouge">&lt;string&gt;</code> because in the header file, Bison wants to use it for making the <code class="language-plaintext highlighter-rouge">IDENT</code> constructor. (I don’t know if I should add <code class="language-plaintext highlighter-rouge">#pragma once</code> or not but just in case). <strong>Note in (1) we did forward declreation because we want to override <code class="language-plaintext highlighter-rouge">yylex()</code> (as you will see next) which belongs to the class <code class="language-plaintext highlighter-rouge">parser</code> while the class definition will be after the overriding. For more info about Forward Decleration <a href="https://stackoverflow.com/questions/4757565/what-are-forward-declarations-in-c">read this</a></strong>.</p></li><li><strong>We defined <code class="language-plaintext highlighter-rouge">yylex()</code> (which belongs to the yy namespace in the C++ API) inside the <code class="language-plaintext highlighter-rouge">%code requires</code> block to make sure that the definition will be before any generated code.</strong> (Also, remember that to override a function inside a name space in C++, you have to put it inside the namespace like I did. aka <strong>defining it like : <code class="language-plaintext highlighter-rouge">yy::yylex()</code> won’t work</strong>).<br /> <strong>Note: in (2) we wrote <code class="language-plaintext highlighter-rouge">parser::</code> because <code class="language-plaintext highlighter-rouge">yylex</code> function belongs to the class <code class="language-plaintext highlighter-rouge">parser</code> (not a namespace!!)</strong></li><li>As you can remember from the C API, we have <code class="language-plaintext highlighter-rouge">yyerror</code> function but <strong>we don’t have to rewrite the signature of it because it will be generated anyway and we just have to write the impelementation as said in (3)</strong>.</li><li>Now we have to define the tokens and using <code class="language-plaintext highlighter-rouge">%token</code> and rewrite the names of the ones which have a type to specify the type to Bison using <code class="language-plaintext highlighter-rouge">%type &lt;some_type_name&gt;</code>. Now as we said in the first point, there will be a constructor for each type with a prameter of its type. (we will use this soon don’t worry).</li><li>In the grammar rules section, I declared an empty rule for <code class="language-plaintext highlighter-rouge">Program</code> so that the parser will have a starting point <strong>(Note that always there should be such rule, otherwise the parser mostly will return a syntax error and won’t run from the first place)</strong> <br /> <br /> Now inside <code class="language-plaintext highlighter-rouge">Parser.tab.hpp</code> there’s :<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>static symbol_type make_IDENT (const std::string&amp; v)
{
  return symbol_type (token::IDENT, v);
}
</pre></table></code></div></div></li></ol><ul><li><p>This is a generated function which returns a type called <code class="language-plaintext highlighter-rouge">symbol_type</code> which Bison understands and supports for applying its grammar but as you can see, we should give it a string as a parameter (which is passed by a const refrernce of course since it’s faster). Also, notice that it sends something else in addition to the string: <code class="language-plaintext highlighter-rouge">token::IDENT</code> where <code class="language-plaintext highlighter-rouge">token</code> is an enum and <code class="language-plaintext highlighter-rouge">IDENT</code> is one of the values which that enum can take.</p></li><li>There are similar functions and enum values for the other tokens <code class="language-plaintext highlighter-rouge">VAR, INT, IS</code> but for example we have:<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>static symbol_type make_VAR ()
{
return symbol_type (token::VAR);
}
</pre></table></code></div></div></li><li>We don’t have a parameter and it only keeps the enum inside the symoble info (calling <code class="language-plaintext highlighter-rouge">symbol_type</code> constructor with 1 parameter) because we don’t have a type attached to this token so that’s all Bison needs in this case.</li></ul><p>Now it’s time to integrate our Bison parser with our C++ scanner using the make_ methods in addition to using the correct way to define and override the parser class function.</p><p>The scanner will have this code : (comments might be repeated for the final version and for better understanding)</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
</pre><td class="rouge-code"><pre>#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include&lt;string&gt;
#include "parser.tab.hpp"
// I know that global variables are often bad. Forgive me I wanna just explain the idea ((
std::ifstream fin;

yy::parser::symbol_type get_next_token()
{
    std::string s;
    char c;
    while (true)
    {
        // could be done better but organized it like this to edit only assignments and returns when using Bison API
        if (!fin.eof())
            fin.get(c);// get one character
        else // return the end of the file so the parser will stop
            return yy::parser::make_YYEOF();

        if (c == ' ' || c == '\n' || fin.eof())
        {
            if (s.empty()) // we only have this character
            {
                if (fin.eof())
                    return yy::parser::make_YYEOF();
                    
                //otherwise go and see what's next
                return get_next_token();
            }
            else
            {
                if (!fin.eof())
                {
                   // now we need to put the pointer exactly after the word (undo the last step)
                   fin.unget();
                }

                if (s == "var") // the last word is var
                    return yy::parser::make_VAR();
                if (s == "integer")
                    return yy::parser::make_INT();
                if (s == "is")
                   return yy::parser::make_IS();
                if (!s.empty())// it means it is some identifier name 
                   return yy::parser::make_IDENT(s); // don't forget to pass the identifier name stored in the string
            }
        }
        else if ((c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || c == '_') // reading some name
        {
            s += c; // add the char to the string
        }
        else
        {
            // we don't know what's that so return undefined token
            return yy::parser::make_YYUNDEF();
        }
    }
}
int main()
{
    fin.open("input.txt");
    yy::parser p;
	p.parse();
    return 0;
}

namespace yy
{
    parser::symbol_type yylex()
    {
        return get_next_token();
    }
}
</pre></table></code></div></div><p>and for the parser code :</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre>%require "3.2"
%language "C++"
%define api.value.type variant
%define api.token.constructor
%define parse.assert

%code requires
{
    #pragma once
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    
    // forward decleration (1)
    namespace yy
    {
        class parser;
    }
}

%code
{    
    namespace yy
    {
        parser::symbol_type yylex(); // override (2)
        // no need to override the error function because it is already waiting for our implementation (3)
    }
    /* 
    because this function is in the main cpp file, we have to tell the compiler that its definition is outside so that Bison won't also generate an implementation by itself.
    */
    extern yy::parser::symbol_type get_next_token();
}

%token IDENT VAR INT IS
%type &lt;std::string&gt; IDENT

%%

Program:
|Program VariableDeclaration
;

VariableDeclaration: VAR IDENT IS INT { std::cout &lt;&lt; "defined an int variable " &lt;&lt; $2 &lt;&lt; "\n"; /* now we will print what we have */ }
;

%%
namespace yy
{
    void parser::error(const std::string&amp; msg) //(3+)
    {
        std::cout&lt;&lt; "syntax error!\n";
    }
}
</pre></table></code></div></div><p>You can find all the final code examples <a href="https://github.com/TheSharpOwl/Bison_API_Tutorial/tree/main/Cpp">here</a>.</p><p><strong>Further Reading:</strong><br /></p><ol><li><a href="https://www.gnu.org/software/bison/manual/bison.html">Bison Documentation</a>.</li><li><a href="https://github.com/TheSharpOwl/FoobarCompiler/tree/061d6f544a72dcd4acd509b3b933999f4f63a5d6/compiler">My parser for an imperative programming language</a> (it is C++ Scanner using Bison’s C API but it would be useful to read).</li><li><a href="https://www.amazon.com/flex-bison-Text-Processing-Tools/dp/0596155972">Flex &amp; Bison: Text Processing Tools 1st Edition book by John Levine</a>.</li></ol><script data-ad-client="ca-pub-2669958432404783" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/compilers/'>Compilers</a>, <a href='/categories/bison/'>Bison</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >Cpp</a> <a href="/tags/bison/" class="post-tag no-text-decoration" >Bison</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Using Bison C++ API With Hand-written Scanner - The Sharp Owl&url=https://TheSharpOwl.github.io/posts/HAND_WRITTEN_SCANNER_WITH_BISON_Cpp_API/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Using Bison C++ API With Hand-written Scanner - The Sharp Owl&u=https://TheSharpOwl.github.io/posts/HAND_WRITTEN_SCANNER_WITH_BISON_Cpp_API/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Using Bison C++ API With Hand-written Scanner - The Sharp Owl&url=https://TheSharpOwl.github.io/posts/HAND_WRITTEN_SCANNER_WITH_BISON_Cpp_API/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/HAND_WRITTEN_SCANNER_WITH_BISON_Cpp_API/">Using Bison C++ API With Hand-written Scanner</a></li><li><a href="/posts/HAND_WRITTEN_SCANNER_WITH_BISON_C_API/">Using Bison C API With Hand-written Scanner</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/bison/">Bison</a> <a class="post-tag" href="/tags/cpp/">Cpp</a> <a class="post-tag" href="/tags/c/">C</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/HAND_WRITTEN_SCANNER_WITH_BISON_C_API/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Oct 18, 2020 <i class="unloaded">2020-10-18T12:00:00+03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Using Bison C API With Hand-written Scanner</h3><div class="text-muted small"><p> You may have a compilers course and wanna learn how to use Bison with your other code. When I had this course I got in a big confusion while trying to use Bison with a Hand Written parser (in my o...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/posts/HAND_WRITTEN_SCANNER_WITH_BISON_C_API/" class="btn btn-outline-primary"><p>Using Bison C API With Hand-written Scanner</p></a> <span class="btn btn-outline-primary disabled"><p>-</p></span></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/Ziad_Kabakibi">Mohamad Ziad Alkabakibi</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/">Chirpy</a> theme.</p></div></div></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/bison/">Bison</a> <a class="post-tag" href="/tags/cpp/">Cpp</a> <a class="post-tag" href="/tags/c/">C</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', '', 'auto'); ga('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://TheSharpOwl.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
